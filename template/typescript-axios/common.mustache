/* eslint-disable eslint-comments/no-unlimited-disable */
/* tslint:disable */
/* eslint-disable */
/**
 * rnproject_template-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {Configuration} from './configuration';
import {RequiredError, RequestArgs} from './base';
import axios, {
  AxiosInstance,
  AxiosResponse,
  CancelTokenStatic,
  InternalAxiosRequestConfig,
} from 'axios';
import 'react-native-url-polyfill/auto';
import {store} from 'src/store/store';
import moment from 'moment';
import {authActions} from 'src/store/slices/auth-slice';
import jwt_decode from 'jwt-decode';
import AppConfig from 'src/config/app-config';
import _ from 'lodash';

/**
 *
 * @export
 */
export const DUMMY_BASE_URL = 'https://example.com';

/**
 *
 * @throws {RequiredError}
 * @export
 */
export const assertParamExists = function (
  functionName: string,
  paramName: string,
  paramValue: unknown,
) {
  if (paramValue === null || paramValue === undefined) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`,
    );
  }
};

/**
 *
 * @export
 */
export const setApiKeyToObject = async function (
  object: any,
  keyParamName: string,
  configuration?: Configuration,
) {
  if (configuration && configuration.apiKey) {
    const localVarApiKeyValue =
      typeof configuration.apiKey === 'function'
        ? await configuration.apiKey(keyParamName)
        : await configuration.apiKey;
    object[keyParamName] = localVarApiKeyValue;
  }
};

/**
 *
 * @export
 */
export const setBasicAuthToObject = function (
  object: any,
  configuration?: Configuration,
) {
  if (configuration && (configuration.username || configuration.password)) {
    object['auth'] = {
      username: configuration.username,
      password: configuration.password,
    };
  }
};

/**
 *
 * @export
 */
export const setBearerAuthToObject = async function (
  object: any,
  configuration?: Configuration,
) {
  if (configuration && configuration.accessToken) {
    const accessToken =
      typeof configuration.accessToken === 'function'
        ? await configuration.accessToken()
        : await configuration.accessToken;
    object['Authorization'] = 'Bearer ' + accessToken;
  }
};

/**
 *
 * @export
 */
export const setOAuthToObject = async function (
  object: any,
  name: string,
  scopes: string[],
  configuration?: Configuration,
) {
  if (configuration && configuration.accessToken) {
    const localVarAccessTokenValue =
      typeof configuration.accessToken === 'function'
        ? await configuration.accessToken(name, scopes)
        : await configuration.accessToken;
    object['Authorization'] = 'Bearer ' + localVarAccessTokenValue;
  }
};

/**
 *
 * @export
 */
export const setSearchParams = function (url: URL, ...objects: any[]) {
  const searchParams = new URLSearchParams(url.search);
  for (const object of objects) {
    for (const key in object) {
      if (Array.isArray(object[key])) {
        searchParams.delete(key);
        for (const item of object[key]) {
          searchParams.append(key, item);
        }
      } else {
        searchParams.set(key, object[key]);
      }
    }
  }
  url.search = searchParams.toString();
};

/**
 *
 * @export
 */
export const serializeDataIfNeeded = function (
  value: any,
  requestOptions: any,
  configuration?: Configuration,
) {
  const nonString = typeof value !== 'string';
  const needsSerialization =
    nonString && configuration && configuration.isJsonMime
      ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
      : nonString;
  return needsSerialization
    ? JSON.stringify(value ?? {})
    : value || '';
};

/**
 *
 * @export
 */
export const toPathString = function (url: URL) {
  return url.pathname + url.search + url.hash;
};

/**
 *
 * @export
 */
const cancelToken: CancelTokenStatic = axios.CancelToken;
let cancelSource = cancelToken.source();
export const refreshToken = () => {
  cancelSource = cancelToken.source();
};
export const cancelAllRequests = () => {
  cancelSource.cancel('CANCEL');
};
export const createRequestFunction = function (
  axiosArgs: RequestArgs,
  globalAxios: AxiosInstance,
  BASE_PATH: string,
  configuration?: Configuration,
) {
  return <T = unknown, R = AxiosResponse<T>>(
    axiosInstance: AxiosInstance = globalAxios,
    basePath: string = BASE_PATH,
  ) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: (configuration ? configuration.basePath : basePath) + axiosArgs.url,
      cancelToken: cancelSource.token,
    };
    return axiosInstance.request<T, R>(axiosRequestArgs);
  };
};

axios.defaults.withCredentials = true;

axios.interceptors.request.use(
  async (config: InternalAxiosRequestConfig<any>) => {
    try {
      const token: string = await getAccessTokenAsync();
      config.headers['Authorization'] = `Bearer ${token || ''}`;
    } catch (error) {
      console.info('Configuration header error: ', error);
    }
    console.info('Configuration header fetch: ', [config]);
    return config;
  },
  error => {
    return Promise.reject(error);
  },
);

const getAccessTokenAsync = async () => {
  const currentUser = store.getState().auth.currentUser;
  let expireTime = 0;
  if (!_.isEmpty(currentUser)) {
    const decodedAccessToken = jwt_decode(currentUser?.accessToken || '');
    expireTime = decodedAccessToken?.exp || 0;
  }
  if (!expireTime) {
    return currentUser?.accessToken;
  } else {
    const now = moment();
    const expire = moment.unix(expireTime);
    if (expire.diff(now, 'minutes') <= 5) {
      try {
        const resultRefreshToken = await refreshTokenApi(
          currentUser?.accessToken || '',
          currentUser?.refreshToken || '',
        );
        console.log('resultRefreshToken', resultRefreshToken);
        store.dispatch(authActions.refreshTokenSuccess?.(resultRefreshToken));
        return resultRefreshToken?.accessToken || '';
      } catch (error) {
        console.info('fetching refresh token error: ', error);
        return currentUser?.accessToken || '';
      }
    } else {
      const accessToken = currentUser?.accessToken || '';
      return accessToken;
    }
  }
};

const refreshTokenApi = async (accessToken: string, refreshTokens: string) => {
  try {
    const refreshTokenSubmit = {refreshToken: refreshTokens};
    const response = await fetch(`${AppConfig.API_URL}/auth/refresh-token`, {
      method: 'POST',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        Authorization: `Bearer ${accessToken || ''}`,
      },
      body: JSON.stringify(refreshTokenSubmit),
    });

    if (!response.ok) {
      throw new Error('Error refreshing token');
    }
    console.log('response refreshTokenApi', response);
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Error refreshing token:', error);
    throw error;
  }
};
